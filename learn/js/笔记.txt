##常用函数
isNaN() // 判断是否为NaN 数字带引号都可以
parseFloat() // 转换为浮点数 第一个不是数字会返回NaN eg.100岁-》100
parseInt() // 转换为整数 第二个参数表示进制 eg.parseInt('110', 2) => 6  2进制

##window对象
window对象属性：
    document：当前页面的文档对象，可以用来操作页面的元素
    location：当前页面的URL信息，可以用来获取当前页面的URL、跳转页面等
        href：当前页面的URL
        reload()：重新加载当前页面=>刷新
        replace()：跳转 注意跳转地址用引号包裹 替换当前页面=>无历史记录
        assign()：加载新的页面=>有历史记录
    history：当前页面的历史记录，可以用来操作浏览器的前进、后退功能（编写时可不使用window前缀）
    name:设置或获取窗口的名称

##js事件（不熟悉的）
onkeydown：按下键盘按键时触发
onfocus：元素获得焦点时触发
onblur：元素失去焦点时触发

##表单验证
降低服务器压力，提升用户体验
所有表单项元素都value属性
常用：非空、长度、合法性
###表单元素
<form action="提交地址" method="get|post">
  <!-- 表单元素 -->
</form>
前判是否是null或undefined；后者用来判断是否是空字符串
if(name==null || name=="")
select\input等标签中加入name属性。没有该属性时，提交表单会忽略这个字段的值，后端服务器接收不到这个字段。
当用户填写表单并点击“提交”按钮时，表单会将所有有 name 的值，按照 name=value 的格式发送到服务器。


##正则表达式
eg.  var reg = /abc/i;
修饰符：
i：执行对大小写不敏感的匹配
g：执行全局匹配（找到所有匹配的结果）
m：多行匹配
模式：
[a-z]:查找方括号内的任何字符
[0-9]:查找数字
(x|y):查找任何以1分隔的选项
元字符：
\d：查找数字digit
\s:查找空白字符space
\b：查找单词边界boundary
\uxxxx：查找Unicode字符(16进制)
\. : 就是小数点
量词：
n+ ：匹配至少一个字符n （1及以上）
eg. let reg = /a+/;
"a"匹配   "aaa"匹配   ""不匹配
n* :匹配0或多个n  以上三个都匹配 （可多次）
n? :最多匹配1次 （有无）
^ : 匹配开头（字符作为开头）
$ : 匹配结尾
[\u4e00-\u9fa5] 匹配一个汉字字符 注意反斜杠
{2,4}：这个前面的元素出现至少2次，最多4次

##js案例
html：
    table中<tr>row <th>head <td>data
创建元素：
    document.createElement("标签名")
    添加元素属性:
    eg. var option = document.createElement("option");
    option.value = "值";
    option.text = "文本";
    添加到父元素下面：
    parent.appendChild(child);
    移除元素：
    parent.removeChild(child);

##http请求
XMLHttpRequest对象：
    创建对象：var xhr = new XMLHttpRequest();
    初始化请求：xhr.open("请求方式", "请求地址", 是否异步);
    eg. xhr.open("GET", "https://www.baidu.com");
    发送数据：xhr.send();
    请求成功完成并响应后触发： xhr.onload()
    xhr.onload = () => {
        if (xhr.status === 200) {
            console.log(xhr.response); // 处理成功响应
        } else {
            console.error(xhr.statusText); // 处理服务器错误
        }
    };
    真正发送http请求：xhr.send(data); 

使用promise封装异步逻辑，外部就可以使用.then()和.catch()来处理结果。
eg.使用promise处理ajax请求
    function fetchData(url) {
    return new Promise((resolve, reject) => {
        // 发送 XMLHttpRequest 请求
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.onload = () => {
        if (xhr.status === 200) {
            resolve(xhr.response);
        } else {
            // 服务器问题进入
            reject(new Error(xhr.statusText));
        }
        };
        // 网络 或 DNS问题调用
        xhr.onerror = () => reject(new Error('网络错误'));
        // 此前都是配置 只有send之后才是真正发出请求
        xhr.send();
    });
    }

    // 真正使用调用
    fetchData('https://api.example.com/data')
    .then((data) => {
        console.log('获取数据成功:', data);
    })
    .catch((error) => {
        console.error('获取数据失败:', error);
    });

fetch是现代浏览器内置的一个用于发起网络请求的接口。
它用来替代传统的 XMLHttpRequest
提供了更简洁和基于 Promise 的异步请求方式。

eg.使用promise链处理多个异步请求
//fetch 返回一个 Promise，Promise resolve 的结果是一个 Response 对象，而不是解析好的数据
function getUser(userId) {
  return fetch(`/users/${userId}`);
}

function getPosts(userId) {
  return fetch(`/users/${userId}/posts`);
}

// 发送请求获取用户数据，返回一个promise
getUser(123)
  .then((user) => {
    console.log('获取用户信息:', user);
    return getPosts(user.id);
  })
  .then((posts) => {
    console.log('获取用户帖子:', posts);
  })
  .catch((error) => {
    console.error('操作失败:', error);
  });

注意：then块默认向下顺序执行，return不能中断，可以通过throw抛出异常来中断执行。
以上由于fetch返回的是一个promise，所以可以用.then()来处理结果，.catch()来处理错误。

=》async/await
async定义异步函数，函数内部使用await关键字等待异步操作完成，await后面跟一个Promise对象
，如果Promise对象状态变为resolved则返回该Promise对象的结果，如果Promise对象状态变为rejected，则抛出该Promise对象的错误。

回调函数：作为参数传递给另一个函数的函数。